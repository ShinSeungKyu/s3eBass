/*
 * WARNING: this is an autogenerated file and will be overwritten by
 * the extension interface script.
 */

#include "s3eExt.h"
#include "IwDebug.h"
#include "s3eDevice.h"


#include "s3eBass.h"

/**
 * Definitions for functions types passed to/from s3eExt interface
 */
typedef       BOOL(*s3eBASS_SetConfig_t)(DWORD option, DWORD value);
typedef      DWORD(*s3eBASS_GetConfig_t)(DWORD option);
typedef       BOOL(*s3eBASS_SetConfigPtr_t)(DWORD option, void* value);
typedef      void*(*s3eBASS_GetConfigPtr_t)(DWORD option);
typedef      DWORD(*s3eBASS_GetVersion_t)();
typedef        int(*s3eBASS_ErrorGetCode_t)();
typedef       BOOL(*s3eBASS_GetDeviceInfo_t)(DWORD device, BASS_DEVICEINFO* info);
typedef       BOOL(*s3eBASS_Init_t)(int device, DWORD freq, DWORD flags, void* win, void* dsguid);
typedef       BOOL(*s3eBASS_SetDevice_t)(DWORD device);
typedef      DWORD(*s3eBASS_GetDevice_t)();
typedef       BOOL(*s3eBASS_Free_t)();
typedef       BOOL(*s3eBASS_GetInfo_t)(BASS_INFO* info);
typedef       BOOL(*s3eBASS_Update_t)(DWORD length);
typedef      float(*s3eBASS_GetCPU_t)();
typedef       BOOL(*s3eBASS_Start_t)();
typedef       BOOL(*s3eBASS_Stop_t)();
typedef       BOOL(*s3eBASS_Pause_t)();
typedef       BOOL(*s3eBASS_SetVolume_t)(float volume);
typedef      float(*s3eBASS_GetVolume_t)();
typedef    HPLUGIN(*s3eBASS_PluginLoad_t)(const char* file, DWORD flags);
typedef       BOOL(*s3eBASS_PluginFree_t)(HPLUGIN handle);
typedef const BASS_PLUGININFO*(*s3eBASS_PluginGetInfo_t)(HPLUGIN handle);
typedef       BOOL(*s3eBASS_Set3DFactors_t)(float distf, float rollf, float doppf);
typedef       BOOL(*s3eBASS_Get3DFactors_t)(float* distf, float* rollf, float* doppf);
typedef       BOOL(*s3eBASS_Set3DPosition_t)(const BASS_3DVECTOR* pos, const BASS_3DVECTOR* vel, const BASS_3DVECTOR* front, const BASS_3DVECTOR* top);
typedef       BOOL(*s3eBASS_Get3DPosition_t)(BASS_3DVECTOR* pos, BASS_3DVECTOR* vel, BASS_3DVECTOR* front, BASS_3DVECTOR* top);
typedef       void(*s3eBASS_Apply3D_t)();
typedef     HMUSIC(*s3eBASS_MusicLoad_t)(BOOL mem, const void* file, QWORD offset, DWORD length, DWORD flags, DWORD freq);
typedef       BOOL(*s3eBASS_MusicFree_t)(HMUSIC handle);
typedef    HSAMPLE(*s3eBASS_SampleLoad_t)(BOOL mem, const void* file, QWORD offset, DWORD length, DWORD max, DWORD flags);
typedef    HSAMPLE(*s3eBASS_SampleCreate_t)(DWORD length, DWORD freq, DWORD chans, DWORD max, DWORD flags);
typedef       BOOL(*s3eBASS_SampleFree_t)(HSAMPLE handle);
typedef       BOOL(*s3eBASS_SampleSetData_t)(HSAMPLE handle, const void* buffer);
typedef       BOOL(*s3eBASS_SampleGetData_t)(HSAMPLE handle, void* buffer);
typedef       BOOL(*s3eBASS_SampleGetInfo_t)(HSAMPLE handle, BASS_SAMPLE* info);
typedef       BOOL(*s3eBASS_SampleSetInfo_t)(HSAMPLE handle, const BASS_SAMPLE* info);
typedef   HCHANNEL(*s3eBASS_SampleGetChannel_t)(HSAMPLE handle, BOOL onlynew);
typedef      DWORD(*s3eBASS_SampleGetChannels_t)(HSAMPLE handle, HCHANNEL* channels);
typedef       BOOL(*s3eBASS_SampleStop_t)(HSAMPLE handle);
typedef    HSTREAM(*s3eBASS_StreamCreate_t)(DWORD freq, DWORD chans, DWORD flags, STREAMPROC* proc, void* user);
typedef    HSTREAM(*s3eBASS_StreamCreateFile_t)(BOOL mem, const void* file, QWORD offset, QWORD length, DWORD flags);
typedef    HSTREAM(*s3eBASS_StreamCreateURL_t)(const char* url, DWORD offset, DWORD flags, DOWNLOADPROC* proc, void* user);
typedef    HSTREAM(*s3eBASS_StreamCreateFileUser_t)(DWORD system, DWORD flags, const BASS_FILEPROCS* proc, void* user);
typedef       BOOL(*s3eBASS_StreamFree_t)(HSTREAM handle);
typedef      QWORD(*s3eBASS_StreamGetFilePosition_t)(HSTREAM handle, DWORD mode);
typedef      DWORD(*s3eBASS_StreamPutData_t)(HSTREAM handle, const void* buffer, DWORD length);
typedef      DWORD(*s3eBASS_StreamPutFileData_t)(HSTREAM handle, const void* buffer, DWORD length);
typedef       BOOL(*s3eBASS_RecordGetDeviceInfo_t)(DWORD device, BASS_DEVICEINFO* info);
typedef       BOOL(*s3eBASS_RecordInit_t)(int device);
typedef       BOOL(*s3eBASS_RecordSetDevice_t)(DWORD device);
typedef      DWORD(*s3eBASS_RecordGetDevice_t)();
typedef       BOOL(*s3eBASS_RecordFree_t)();
typedef       BOOL(*s3eBASS_RecordGetInfo_t)(BASS_RECORDINFO* info);
typedef const char*(*s3eBASS_RecordGetInputName_t)(int input);
typedef       BOOL(*s3eBASS_RecordSetInput_t)(int input, DWORD flags, float volume);
typedef      DWORD(*s3eBASS_RecordGetInput_t)(int input, float* volume);
typedef    HRECORD(*s3eBASS_RecordStart_t)(DWORD freq, DWORD chans, DWORD flags, RECORDPROC* proc, void* user);
typedef     double(*s3eBASS_ChannelBytes2Seconds_t)(DWORD handle, QWORD pos);
typedef      QWORD(*s3eBASS_ChannelSeconds2Bytes_t)(DWORD handle, double pos);
typedef      DWORD(*s3eBASS_ChannelGetDevice_t)(DWORD handle);
typedef       BOOL(*s3eBASS_ChannelSetDevice_t)(DWORD handle, DWORD device);
typedef      DWORD(*s3eBASS_ChannelIsActive_t)(DWORD handle);
typedef       BOOL(*s3eBASS_ChannelGetInfo_t)(DWORD handle, BASS_CHANNELINFO* info);
typedef const char*(*s3eBASS_ChannelGetTags_t)(DWORD handle, DWORD tags);
typedef      DWORD(*s3eBASS_ChannelFlags_t)(DWORD handle, DWORD flags, DWORD mask);
typedef       BOOL(*s3eBASS_ChannelUpdate_t)(DWORD handle, DWORD length);
typedef       BOOL(*s3eBASS_ChannelLock_t)(DWORD handle, BOOL lock);
typedef       BOOL(*s3eBASS_ChannelPlay_t)(DWORD handle, BOOL restart);
typedef       BOOL(*s3eBASS_ChannelStop_t)(DWORD handle);
typedef       BOOL(*s3eBASS_ChannelPause_t)(DWORD handle);
typedef       BOOL(*s3eBASS_ChannelSetAttribute_t)(DWORD handle, DWORD attrib, float value);
typedef       BOOL(*s3eBASS_ChannelGetAttribute_t)(DWORD handle, DWORD attrib, float* value);
typedef       BOOL(*s3eBASS_ChannelSlideAttribute_t)(DWORD handle, DWORD attrib, float value, DWORD time);
typedef       BOOL(*s3eBASS_ChannelIsSliding_t)(DWORD handle, DWORD attrib);
typedef       BOOL(*s3eBASS_ChannelSet3DAttributes_t)(DWORD handle, int mode, float min, float max, int iangle, int oangle, float outvol);
typedef       BOOL(*s3eBASS_ChannelGet3DAttributes_t)(DWORD handle, DWORD* mode, float* min, float* max, DWORD* iangle, DWORD* oangle, float* outvol);
typedef       BOOL(*s3eBASS_ChannelSet3DPosition_t)(DWORD handle, const BASS_3DVECTOR* pos, const BASS_3DVECTOR* orient, const BASS_3DVECTOR* vel);
typedef       BOOL(*s3eBASS_ChannelGet3DPosition_t)(DWORD handle, BASS_3DVECTOR* pos, BASS_3DVECTOR* orient, BASS_3DVECTOR* vel);
typedef      QWORD(*s3eBASS_ChannelGetLength_t)(DWORD handle, DWORD mode);
typedef       BOOL(*s3eBASS_ChannelSetPosition_t)(DWORD handle, QWORD pos, DWORD mode);
typedef      QWORD(*s3eBASS_ChannelGetPosition_t)(DWORD handle, DWORD mode);
typedef      DWORD(*s3eBASS_ChannelGetLevel_t)(DWORD handle);
typedef      DWORD(*s3eBASS_ChannelGetData_t)(DWORD handle, void* buffer, DWORD length);
typedef      HSYNC(*s3eBASS_ChannelSetSync_t)(DWORD handle, DWORD type, QWORD param, SYNCPROC* proc, void* user);
typedef       BOOL(*s3eBASS_ChannelRemoveSync_t)(DWORD handle, HSYNC sync);
typedef       HDSP(*s3eBASS_ChannelSetDSP_t)(DWORD handle, DSPPROC* proc, void* user, int priority);
typedef       BOOL(*s3eBASS_ChannelRemoveDSP_t)(DWORD handle, HDSP dsp);
typedef       BOOL(*s3eBASS_ChannelSetLink_t)(DWORD handle, DWORD chan);
typedef       BOOL(*s3eBASS_ChannelRemoveLink_t)(DWORD handle, DWORD chan);
typedef        HFX(*s3eBASS_ChannelSetFX_t)(DWORD handle, DWORD type, int priority);
typedef       BOOL(*s3eBASS_ChannelRemoveFX_t)(DWORD handle, HFX fx);
typedef       BOOL(*s3eBASS_FXSetParameters_t)(HFX handle, const void* params);
typedef       BOOL(*s3eBASS_FXGetParameters_t)(HFX handle, void* params);
typedef       BOOL(*s3eBASS_FXReset_t)(HFX handle);

/**
 * struct that gets filled in by s3eBassRegister
 */
typedef struct s3eBassFuncs
{
    s3eBASS_SetConfig_t m_s3eBASS_SetConfig;
    s3eBASS_GetConfig_t m_s3eBASS_GetConfig;
    s3eBASS_SetConfigPtr_t m_s3eBASS_SetConfigPtr;
    s3eBASS_GetConfigPtr_t m_s3eBASS_GetConfigPtr;
    s3eBASS_GetVersion_t m_s3eBASS_GetVersion;
    s3eBASS_ErrorGetCode_t m_s3eBASS_ErrorGetCode;
    s3eBASS_GetDeviceInfo_t m_s3eBASS_GetDeviceInfo;
    s3eBASS_Init_t m_s3eBASS_Init;
    s3eBASS_SetDevice_t m_s3eBASS_SetDevice;
    s3eBASS_GetDevice_t m_s3eBASS_GetDevice;
    s3eBASS_Free_t m_s3eBASS_Free;
    s3eBASS_GetInfo_t m_s3eBASS_GetInfo;
    s3eBASS_Update_t m_s3eBASS_Update;
    s3eBASS_GetCPU_t m_s3eBASS_GetCPU;
    s3eBASS_Start_t m_s3eBASS_Start;
    s3eBASS_Stop_t m_s3eBASS_Stop;
    s3eBASS_Pause_t m_s3eBASS_Pause;
    s3eBASS_SetVolume_t m_s3eBASS_SetVolume;
    s3eBASS_GetVolume_t m_s3eBASS_GetVolume;
    s3eBASS_PluginLoad_t m_s3eBASS_PluginLoad;
    s3eBASS_PluginFree_t m_s3eBASS_PluginFree;
    s3eBASS_PluginGetInfo_t m_s3eBASS_PluginGetInfo;
    s3eBASS_Set3DFactors_t m_s3eBASS_Set3DFactors;
    s3eBASS_Get3DFactors_t m_s3eBASS_Get3DFactors;
    s3eBASS_Set3DPosition_t m_s3eBASS_Set3DPosition;
    s3eBASS_Get3DPosition_t m_s3eBASS_Get3DPosition;
    s3eBASS_Apply3D_t m_s3eBASS_Apply3D;
    s3eBASS_MusicLoad_t m_s3eBASS_MusicLoad;
    s3eBASS_MusicFree_t m_s3eBASS_MusicFree;
    s3eBASS_SampleLoad_t m_s3eBASS_SampleLoad;
    s3eBASS_SampleCreate_t m_s3eBASS_SampleCreate;
    s3eBASS_SampleFree_t m_s3eBASS_SampleFree;
    s3eBASS_SampleSetData_t m_s3eBASS_SampleSetData;
    s3eBASS_SampleGetData_t m_s3eBASS_SampleGetData;
    s3eBASS_SampleGetInfo_t m_s3eBASS_SampleGetInfo;
    s3eBASS_SampleSetInfo_t m_s3eBASS_SampleSetInfo;
    s3eBASS_SampleGetChannel_t m_s3eBASS_SampleGetChannel;
    s3eBASS_SampleGetChannels_t m_s3eBASS_SampleGetChannels;
    s3eBASS_SampleStop_t m_s3eBASS_SampleStop;
    s3eBASS_StreamCreate_t m_s3eBASS_StreamCreate;
    s3eBASS_StreamCreateFile_t m_s3eBASS_StreamCreateFile;
    s3eBASS_StreamCreateURL_t m_s3eBASS_StreamCreateURL;
    s3eBASS_StreamCreateFileUser_t m_s3eBASS_StreamCreateFileUser;
    s3eBASS_StreamFree_t m_s3eBASS_StreamFree;
    s3eBASS_StreamGetFilePosition_t m_s3eBASS_StreamGetFilePosition;
    s3eBASS_StreamPutData_t m_s3eBASS_StreamPutData;
    s3eBASS_StreamPutFileData_t m_s3eBASS_StreamPutFileData;
    s3eBASS_RecordGetDeviceInfo_t m_s3eBASS_RecordGetDeviceInfo;
    s3eBASS_RecordInit_t m_s3eBASS_RecordInit;
    s3eBASS_RecordSetDevice_t m_s3eBASS_RecordSetDevice;
    s3eBASS_RecordGetDevice_t m_s3eBASS_RecordGetDevice;
    s3eBASS_RecordFree_t m_s3eBASS_RecordFree;
    s3eBASS_RecordGetInfo_t m_s3eBASS_RecordGetInfo;
    s3eBASS_RecordGetInputName_t m_s3eBASS_RecordGetInputName;
    s3eBASS_RecordSetInput_t m_s3eBASS_RecordSetInput;
    s3eBASS_RecordGetInput_t m_s3eBASS_RecordGetInput;
    s3eBASS_RecordStart_t m_s3eBASS_RecordStart;
    s3eBASS_ChannelBytes2Seconds_t m_s3eBASS_ChannelBytes2Seconds;
    s3eBASS_ChannelSeconds2Bytes_t m_s3eBASS_ChannelSeconds2Bytes;
    s3eBASS_ChannelGetDevice_t m_s3eBASS_ChannelGetDevice;
    s3eBASS_ChannelSetDevice_t m_s3eBASS_ChannelSetDevice;
    s3eBASS_ChannelIsActive_t m_s3eBASS_ChannelIsActive;
    s3eBASS_ChannelGetInfo_t m_s3eBASS_ChannelGetInfo;
    s3eBASS_ChannelGetTags_t m_s3eBASS_ChannelGetTags;
    s3eBASS_ChannelFlags_t m_s3eBASS_ChannelFlags;
    s3eBASS_ChannelUpdate_t m_s3eBASS_ChannelUpdate;
    s3eBASS_ChannelLock_t m_s3eBASS_ChannelLock;
    s3eBASS_ChannelPlay_t m_s3eBASS_ChannelPlay;
    s3eBASS_ChannelStop_t m_s3eBASS_ChannelStop;
    s3eBASS_ChannelPause_t m_s3eBASS_ChannelPause;
    s3eBASS_ChannelSetAttribute_t m_s3eBASS_ChannelSetAttribute;
    s3eBASS_ChannelGetAttribute_t m_s3eBASS_ChannelGetAttribute;
    s3eBASS_ChannelSlideAttribute_t m_s3eBASS_ChannelSlideAttribute;
    s3eBASS_ChannelIsSliding_t m_s3eBASS_ChannelIsSliding;
    s3eBASS_ChannelSet3DAttributes_t m_s3eBASS_ChannelSet3DAttributes;
    s3eBASS_ChannelGet3DAttributes_t m_s3eBASS_ChannelGet3DAttributes;
    s3eBASS_ChannelSet3DPosition_t m_s3eBASS_ChannelSet3DPosition;
    s3eBASS_ChannelGet3DPosition_t m_s3eBASS_ChannelGet3DPosition;
    s3eBASS_ChannelGetLength_t m_s3eBASS_ChannelGetLength;
    s3eBASS_ChannelSetPosition_t m_s3eBASS_ChannelSetPosition;
    s3eBASS_ChannelGetPosition_t m_s3eBASS_ChannelGetPosition;
    s3eBASS_ChannelGetLevel_t m_s3eBASS_ChannelGetLevel;
    s3eBASS_ChannelGetData_t m_s3eBASS_ChannelGetData;
    s3eBASS_ChannelSetSync_t m_s3eBASS_ChannelSetSync;
    s3eBASS_ChannelRemoveSync_t m_s3eBASS_ChannelRemoveSync;
    s3eBASS_ChannelSetDSP_t m_s3eBASS_ChannelSetDSP;
    s3eBASS_ChannelRemoveDSP_t m_s3eBASS_ChannelRemoveDSP;
    s3eBASS_ChannelSetLink_t m_s3eBASS_ChannelSetLink;
    s3eBASS_ChannelRemoveLink_t m_s3eBASS_ChannelRemoveLink;
    s3eBASS_ChannelSetFX_t m_s3eBASS_ChannelSetFX;
    s3eBASS_ChannelRemoveFX_t m_s3eBASS_ChannelRemoveFX;
    s3eBASS_FXSetParameters_t m_s3eBASS_FXSetParameters;
    s3eBASS_FXGetParameters_t m_s3eBASS_FXGetParameters;
    s3eBASS_FXReset_t m_s3eBASS_FXReset;
} s3eBassFuncs;

static s3eBassFuncs g_Ext;
static bool g_GotExt = false;
static bool g_TriedExt = false;
static bool g_TriedNoMsgExt = false;

static bool _extLoad()
{
    if (!g_GotExt && !g_TriedExt)
    {
        s3eResult res = s3eExtGetHash(0x167b1419, &g_Ext, sizeof(g_Ext));
        if (res == S3E_RESULT_SUCCESS)
            g_GotExt = true;
        else
            s3eDebugAssertShow(S3E_MESSAGE_CONTINUE_STOP_IGNORE,                 "error loading extension: s3eBass");
            
        g_TriedExt = true;
        g_TriedNoMsgExt = true;
    }

    return g_GotExt;
}

static bool _extLoadNoMsg()
{
    if (!g_GotExt && !g_TriedNoMsgExt)
    {
        s3eResult res = s3eExtGetHash(0x167b1419, &g_Ext, sizeof(g_Ext));
        if (res == S3E_RESULT_SUCCESS)
            g_GotExt = true;
        g_TriedNoMsgExt = true;
        if (g_TriedExt)
            g_TriedExt = true;
    }

    return g_GotExt;
}

s3eBool s3eBassAvailable()
{
    _extLoadNoMsg();
    return g_GotExt ? S3E_TRUE : S3E_FALSE;
}

BOOL s3eBASS_SetConfig(DWORD option, DWORD value)
{
    IwTrace(BASS_VERBOSE, ("calling s3eBass[0] func: s3eBASS_SetConfig"));

    if (!_extLoad())
        return false;

#ifdef __mips
    // For MIPs platform we do not have asm code for stack switching 
    // implemented. So we make LoaderCallStart call manually to set GlobalLock
    s3eDeviceLoaderCallStart(S3E_TRUE, NULL);
#endif

    BOOL ret = g_Ext.m_s3eBASS_SetConfig(option, value);

#ifdef __mips
    s3eDeviceLoaderCallDone(S3E_TRUE, NULL);
#endif

    return ret;
}

DWORD s3eBASS_GetConfig(DWORD option)
{
    IwTrace(BASS_VERBOSE, ("calling s3eBass[1] func: s3eBASS_GetConfig"));

    if (!_extLoad())
        return false;

#ifdef __mips
    // For MIPs platform we do not have asm code for stack switching 
    // implemented. So we make LoaderCallStart call manually to set GlobalLock
    s3eDeviceLoaderCallStart(S3E_TRUE, NULL);
#endif

    DWORD ret = g_Ext.m_s3eBASS_GetConfig(option);

#ifdef __mips
    s3eDeviceLoaderCallDone(S3E_TRUE, NULL);
#endif

    return ret;
}

BOOL s3eBASS_SetConfigPtr(DWORD option, void *value)
{
    IwTrace(BASS_VERBOSE, ("calling s3eBass[2] func: s3eBASS_SetConfigPtr"));

    if (!_extLoad())
        return false;

#ifdef __mips
    // For MIPs platform we do not have asm code for stack switching 
    // implemented. So we make LoaderCallStart call manually to set GlobalLock
    s3eDeviceLoaderCallStart(S3E_TRUE, NULL);
#endif

    BOOL ret = g_Ext.m_s3eBASS_SetConfigPtr(option, value);

#ifdef __mips
    s3eDeviceLoaderCallDone(S3E_TRUE, NULL);
#endif

    return ret;
}

void *s3eBASS_GetConfigPtr(DWORD option)
{
    IwTrace(BASS_VERBOSE, ("calling s3eBass[3] func: *s3eBASS_GetConfigPtr"));

    if (!_extLoad())
        return NULL;

#ifdef __mips
    // For MIPs platform we do not have asm code for stack switching 
    // implemented. So we make LoaderCallStart call manually to set GlobalLock
    s3eDeviceLoaderCallStart(S3E_TRUE, NULL);
#endif

    return g_Ext.m_s3eBASS_GetConfigPtr(option);

#ifdef __mips
    s3eDeviceLoaderCallDone(S3E_TRUE, NULL);
#endif

    return NULL;
}

DWORD s3eBASS_GetVersion()
{
    IwTrace(BASS_VERBOSE, ("calling s3eBass[4] func: s3eBASS_GetVersion"));

    if (!_extLoad())
        return 0;

#ifdef __mips
    // For MIPs platform we do not have asm code for stack switching 
    // implemented. So we make LoaderCallStart call manually to set GlobalLock
    s3eDeviceLoaderCallStart(S3E_TRUE, NULL);
#endif

    DWORD ret = g_Ext.m_s3eBASS_GetVersion();

#ifdef __mips
    s3eDeviceLoaderCallDone(S3E_TRUE, NULL);
#endif

    return ret;
}

int s3eBASS_ErrorGetCode()
{
    IwTrace(BASS_VERBOSE, ("calling s3eBass[5] func: s3eBASS_ErrorGetCode"));

    if (!_extLoad())
        return -1;

#ifdef __mips
    // For MIPs platform we do not have asm code for stack switching 
    // implemented. So we make LoaderCallStart call manually to set GlobalLock
    s3eDeviceLoaderCallStart(S3E_TRUE, NULL);
#endif

    int ret = g_Ext.m_s3eBASS_ErrorGetCode();

#ifdef __mips
    s3eDeviceLoaderCallDone(S3E_TRUE, NULL);
#endif

    return ret;
}

BOOL s3eBASS_GetDeviceInfo(DWORD device, BASS_DEVICEINFO *info)
{
    IwTrace(BASS_VERBOSE, ("calling s3eBass[6] func: s3eBASS_GetDeviceInfo"));

    if (!_extLoad())
        return false;

#ifdef __mips
    // For MIPs platform we do not have asm code for stack switching 
    // implemented. So we make LoaderCallStart call manually to set GlobalLock
    s3eDeviceLoaderCallStart(S3E_TRUE, NULL);
#endif

    BOOL ret = g_Ext.m_s3eBASS_GetDeviceInfo(device, info);

#ifdef __mips
    s3eDeviceLoaderCallDone(S3E_TRUE, NULL);
#endif

    return ret;
}

BOOL s3eBASS_Init(int device, DWORD freq, DWORD flags, void *win, void *dsguid)
{
    IwTrace(BASS_VERBOSE, ("calling s3eBass[7] func: s3eBASS_Init"));

    if (!_extLoad())
        return false;

#ifdef __mips
    // For MIPs platform we do not have asm code for stack switching 
    // implemented. So we make LoaderCallStart call manually to set GlobalLock
    s3eDeviceLoaderCallStart(S3E_TRUE, NULL);
#endif

    BOOL ret = g_Ext.m_s3eBASS_Init(device, freq, flags, win, dsguid);

#ifdef __mips
    s3eDeviceLoaderCallDone(S3E_TRUE, NULL);
#endif

    return ret;
}

BOOL s3eBASS_SetDevice(DWORD device)
{
    IwTrace(BASS_VERBOSE, ("calling s3eBass[8] func: s3eBASS_SetDevice"));

    if (!_extLoad())
        return false;

#ifdef __mips
    // For MIPs platform we do not have asm code for stack switching 
    // implemented. So we make LoaderCallStart call manually to set GlobalLock
    s3eDeviceLoaderCallStart(S3E_TRUE, NULL);
#endif

    BOOL ret = g_Ext.m_s3eBASS_SetDevice(device);

#ifdef __mips
    s3eDeviceLoaderCallDone(S3E_TRUE, NULL);
#endif

    return ret;
}

DWORD s3eBASS_GetDevice()
{
    IwTrace(BASS_VERBOSE, ("calling s3eBass[9] func: s3eBASS_GetDevice"));

    if (!_extLoad())
        return NULL;

#ifdef __mips
    // For MIPs platform we do not have asm code for stack switching 
    // implemented. So we make LoaderCallStart call manually to set GlobalLock
    s3eDeviceLoaderCallStart(S3E_TRUE, NULL);
#endif

    DWORD ret = g_Ext.m_s3eBASS_GetDevice();

#ifdef __mips
    s3eDeviceLoaderCallDone(S3E_TRUE, NULL);
#endif

    return ret;
}

BOOL s3eBASS_Free()
{
    IwTrace(BASS_VERBOSE, ("calling s3eBass[10] func: s3eBASS_Free"));

    if (!_extLoad())
        return false;

#ifdef __mips
    // For MIPs platform we do not have asm code for stack switching 
    // implemented. So we make LoaderCallStart call manually to set GlobalLock
    s3eDeviceLoaderCallStart(S3E_TRUE, NULL);
#endif

    BOOL ret = g_Ext.m_s3eBASS_Free();

#ifdef __mips
    s3eDeviceLoaderCallDone(S3E_TRUE, NULL);
#endif

    return ret;
}

BOOL s3eBASS_GetInfo(BASS_INFO *info)
{
    IwTrace(BASS_VERBOSE, ("calling s3eBass[11] func: s3eBASS_GetInfo"));

    if (!_extLoad())
        return false;

#ifdef __mips
    // For MIPs platform we do not have asm code for stack switching 
    // implemented. So we make LoaderCallStart call manually to set GlobalLock
    s3eDeviceLoaderCallStart(S3E_TRUE, NULL);
#endif

    BOOL ret = g_Ext.m_s3eBASS_GetInfo(info);

#ifdef __mips
    s3eDeviceLoaderCallDone(S3E_TRUE, NULL);
#endif

    return ret;
}

BOOL s3eBASS_Update(DWORD length)
{
    IwTrace(BASS_VERBOSE, ("calling s3eBass[12] func: s3eBASS_Update"));

    if (!_extLoad())
        return false;

#ifdef __mips
    // For MIPs platform we do not have asm code for stack switching 
    // implemented. So we make LoaderCallStart call manually to set GlobalLock
    s3eDeviceLoaderCallStart(S3E_TRUE, NULL);
#endif

    BOOL ret = g_Ext.m_s3eBASS_Update(length);

#ifdef __mips
    s3eDeviceLoaderCallDone(S3E_TRUE, NULL);
#endif

    return ret;
}

float s3eBASS_GetCPU()
{
    IwTrace(BASS_VERBOSE, ("calling s3eBass[13] func: s3eBASS_GetCPU"));

    if (!_extLoad())
        return 0.0f;

#ifdef __mips
    // For MIPs platform we do not have asm code for stack switching 
    // implemented. So we make LoaderCallStart call manually to set GlobalLock
    s3eDeviceLoaderCallStart(S3E_TRUE, NULL);
#endif

    float ret = g_Ext.m_s3eBASS_GetCPU();

#ifdef __mips
    s3eDeviceLoaderCallDone(S3E_TRUE, NULL);
#endif

    return ret;
}

BOOL s3eBASS_Start()
{
    IwTrace(BASS_VERBOSE, ("calling s3eBass[14] func: s3eBASS_Start"));

    if (!_extLoad())
        return false;

#ifdef __mips
    // For MIPs platform we do not have asm code for stack switching 
    // implemented. So we make LoaderCallStart call manually to set GlobalLock
    s3eDeviceLoaderCallStart(S3E_TRUE, NULL);
#endif

    BOOL ret = g_Ext.m_s3eBASS_Start();

#ifdef __mips
    s3eDeviceLoaderCallDone(S3E_TRUE, NULL);
#endif

    return ret;
}

BOOL s3eBASS_Stop()
{
    IwTrace(BASS_VERBOSE, ("calling s3eBass[15] func: s3eBASS_Stop"));

    if (!_extLoad())
        return false;

#ifdef __mips
    // For MIPs platform we do not have asm code for stack switching 
    // implemented. So we make LoaderCallStart call manually to set GlobalLock
    s3eDeviceLoaderCallStart(S3E_TRUE, NULL);
#endif

    BOOL ret = g_Ext.m_s3eBASS_Stop();

#ifdef __mips
    s3eDeviceLoaderCallDone(S3E_TRUE, NULL);
#endif

    return ret;
}

BOOL s3eBASS_Pause()
{
    IwTrace(BASS_VERBOSE, ("calling s3eBass[16] func: s3eBASS_Pause"));

    if (!_extLoad())
        return false;

#ifdef __mips
    // For MIPs platform we do not have asm code for stack switching 
    // implemented. So we make LoaderCallStart call manually to set GlobalLock
    s3eDeviceLoaderCallStart(S3E_TRUE, NULL);
#endif

    BOOL ret = g_Ext.m_s3eBASS_Pause();

#ifdef __mips
    s3eDeviceLoaderCallDone(S3E_TRUE, NULL);
#endif

    return ret;
}

BOOL s3eBASS_SetVolume(float volume)
{
    IwTrace(BASS_VERBOSE, ("calling s3eBass[17] func: s3eBASS_SetVolume"));

    if (!_extLoad())
        return false;

#ifdef __mips
    // For MIPs platform we do not have asm code for stack switching 
    // implemented. So we make LoaderCallStart call manually to set GlobalLock
    s3eDeviceLoaderCallStart(S3E_TRUE, NULL);
#endif

    BOOL ret = g_Ext.m_s3eBASS_SetVolume(volume);

#ifdef __mips
    s3eDeviceLoaderCallDone(S3E_TRUE, NULL);
#endif

    return ret;
}

float s3eBASS_GetVolume()
{
    IwTrace(BASS_VERBOSE, ("calling s3eBass[18] func: s3eBASS_GetVolume"));

    if (!_extLoad())
        return 0.0f;

#ifdef __mips
    // For MIPs platform we do not have asm code for stack switching 
    // implemented. So we make LoaderCallStart call manually to set GlobalLock
    s3eDeviceLoaderCallStart(S3E_TRUE, NULL);
#endif

    float ret = g_Ext.m_s3eBASS_GetVolume();

#ifdef __mips
    s3eDeviceLoaderCallDone(S3E_TRUE, NULL);
#endif

    return ret;
}

HPLUGIN s3eBASS_PluginLoad(const char *file, DWORD flags)
{
    IwTrace(BASS_VERBOSE, ("calling s3eBass[19] func: s3eBASS_PluginLoad"));

    if (!_extLoad())
        return NULL;

#ifdef __mips
    // For MIPs platform we do not have asm code for stack switching 
    // implemented. So we make LoaderCallStart call manually to set GlobalLock
    s3eDeviceLoaderCallStart(S3E_TRUE, NULL);
#endif

    HPLUGIN ret = g_Ext.m_s3eBASS_PluginLoad(file, flags);

#ifdef __mips
    s3eDeviceLoaderCallDone(S3E_TRUE, NULL);
#endif

    return ret;
}

BOOL s3eBASS_PluginFree(HPLUGIN handle)
{
    IwTrace(BASS_VERBOSE, ("calling s3eBass[20] func: s3eBASS_PluginFree"));

    if (!_extLoad())
        return false;

#ifdef __mips
    // For MIPs platform we do not have asm code for stack switching 
    // implemented. So we make LoaderCallStart call manually to set GlobalLock
    s3eDeviceLoaderCallStart(S3E_TRUE, NULL);
#endif

    BOOL ret = g_Ext.m_s3eBASS_PluginFree(handle);

#ifdef __mips
    s3eDeviceLoaderCallDone(S3E_TRUE, NULL);
#endif

    return ret;
}

const BASS_PLUGININFO *s3eBASS_PluginGetInfo(HPLUGIN handle)
{
    IwTrace(BASS_VERBOSE, ("calling s3eBass[21] func: *s3eBASS_PluginGetInfo"));

    if (!_extLoad())
        return NULL;

#ifdef __mips
    // For MIPs platform we do not have asm code for stack switching 
    // implemented. So we make LoaderCallStart call manually to set GlobalLock
    s3eDeviceLoaderCallStart(S3E_TRUE, NULL);
#endif

    const BASS_PLUGININFO *ret = g_Ext.m_s3eBASS_PluginGetInfo(handle);

#ifdef __mips
    s3eDeviceLoaderCallDone(S3E_TRUE, NULL);
#endif

    return ret;
}

BOOL s3eBASS_Set3DFactors(float distf, float rollf, float doppf)
{
    IwTrace(BASS_VERBOSE, ("calling s3eBass[22] func: s3eBASS_Set3DFactors"));

    if (!_extLoad())
        return false;

#ifdef __mips
    // For MIPs platform we do not have asm code for stack switching 
    // implemented. So we make LoaderCallStart call manually to set GlobalLock
    s3eDeviceLoaderCallStart(S3E_TRUE, NULL);
#endif

    BOOL ret = g_Ext.m_s3eBASS_Set3DFactors(distf, rollf, doppf);

#ifdef __mips
    s3eDeviceLoaderCallDone(S3E_TRUE, NULL);
#endif

    return ret;
}

BOOL s3eBASS_Get3DFactors(float *distf, float *rollf, float *doppf)
{
    IwTrace(BASS_VERBOSE, ("calling s3eBass[23] func: s3eBASS_Get3DFactors"));

    if (!_extLoad())
        return false;

#ifdef __mips
    // For MIPs platform we do not have asm code for stack switching 
    // implemented. So we make LoaderCallStart call manually to set GlobalLock
    s3eDeviceLoaderCallStart(S3E_TRUE, NULL);
#endif

    BOOL ret = g_Ext.m_s3eBASS_Get3DFactors(distf, rollf, doppf);

#ifdef __mips
    s3eDeviceLoaderCallDone(S3E_TRUE, NULL);
#endif

    return ret;
}

BOOL s3eBASS_Set3DPosition(const BASS_3DVECTOR *pos, const BASS_3DVECTOR *vel, const BASS_3DVECTOR *front, const BASS_3DVECTOR *top)
{
    IwTrace(BASS_VERBOSE, ("calling s3eBass[24] func: s3eBASS_Set3DPosition"));

    if (!_extLoad())
        return false;

#ifdef __mips
    // For MIPs platform we do not have asm code for stack switching 
    // implemented. So we make LoaderCallStart call manually to set GlobalLock
    s3eDeviceLoaderCallStart(S3E_TRUE, NULL);
#endif

    BOOL ret = g_Ext.m_s3eBASS_Set3DPosition(pos, vel, front, top);

#ifdef __mips
    s3eDeviceLoaderCallDone(S3E_TRUE, NULL);
#endif

    return ret;
}

BOOL s3eBASS_Get3DPosition(BASS_3DVECTOR *pos, BASS_3DVECTOR *vel, BASS_3DVECTOR *front, BASS_3DVECTOR *top)
{
    IwTrace(BASS_VERBOSE, ("calling s3eBass[25] func: s3eBASS_Get3DPosition"));

    if (!_extLoad())
        return false;

#ifdef __mips
    // For MIPs platform we do not have asm code for stack switching 
    // implemented. So we make LoaderCallStart call manually to set GlobalLock
    s3eDeviceLoaderCallStart(S3E_TRUE, NULL);
#endif

    BOOL ret = g_Ext.m_s3eBASS_Get3DPosition(pos, vel, front, top);

#ifdef __mips
    s3eDeviceLoaderCallDone(S3E_TRUE, NULL);
#endif

    return ret;
}

void s3eBASS_Apply3D()
{
    IwTrace(BASS_VERBOSE, ("calling s3eBass[26] func: s3eBASS_Apply3D"));

    if (!_extLoad())
        return;

#ifdef __mips
    // For MIPs platform we do not have asm code for stack switching 
    // implemented. So we make LoaderCallStart call manually to set GlobalLock
    s3eDeviceLoaderCallStart(S3E_TRUE, NULL);
#endif

    g_Ext.m_s3eBASS_Apply3D();

#ifdef __mips
    s3eDeviceLoaderCallDone(S3E_TRUE, NULL);
#endif

    return;
}

HMUSIC s3eBASS_MusicLoad(BOOL mem, const void *file, QWORD offset, DWORD length, DWORD flags, DWORD freq)
{
    IwTrace(BASS_VERBOSE, ("calling s3eBass[27] func: s3eBASS_MusicLoad"));

    if (!_extLoad())
        return NULL;

#ifdef __mips
    // For MIPs platform we do not have asm code for stack switching 
    // implemented. So we make LoaderCallStart call manually to set GlobalLock
    s3eDeviceLoaderCallStart(S3E_TRUE, NULL);
#endif

    HMUSIC ret = g_Ext.m_s3eBASS_MusicLoad(mem, file, offset, length, flags, freq);

#ifdef __mips
    s3eDeviceLoaderCallDone(S3E_TRUE, NULL);
#endif

    return ret;
}

BOOL s3eBASS_MusicFree(HMUSIC handle)
{
    IwTrace(BASS_VERBOSE, ("calling s3eBass[28] func: s3eBASS_MusicFree"));

    if (!_extLoad())
        return false;

#ifdef __mips
    // For MIPs platform we do not have asm code for stack switching 
    // implemented. So we make LoaderCallStart call manually to set GlobalLock
    s3eDeviceLoaderCallStart(S3E_TRUE, NULL);
#endif

    BOOL ret = g_Ext.m_s3eBASS_MusicFree(handle);

#ifdef __mips
    s3eDeviceLoaderCallDone(S3E_TRUE, NULL);
#endif

    return ret;
}

HSAMPLE s3eBASS_SampleLoad(BOOL mem, const void *file, QWORD offset, DWORD length, DWORD max, DWORD flags)
{
    IwTrace(BASS_VERBOSE, ("calling s3eBass[29] func: s3eBASS_SampleLoad"));

    if (!_extLoad())
        return NULL;

#ifdef __mips
    // For MIPs platform we do not have asm code for stack switching 
    // implemented. So we make LoaderCallStart call manually to set GlobalLock
    s3eDeviceLoaderCallStart(S3E_TRUE, NULL);
#endif

    HSAMPLE ret = g_Ext.m_s3eBASS_SampleLoad(mem, file, offset, length, max, flags);

#ifdef __mips
    s3eDeviceLoaderCallDone(S3E_TRUE, NULL);
#endif

    return ret;
}

HSAMPLE s3eBASS_SampleCreate(DWORD length, DWORD freq, DWORD chans, DWORD max, DWORD flags)
{
    IwTrace(BASS_VERBOSE, ("calling s3eBass[30] func: s3eBASS_SampleCreate"));

    if (!_extLoad())
        return NULL;

#ifdef __mips
    // For MIPs platform we do not have asm code for stack switching 
    // implemented. So we make LoaderCallStart call manually to set GlobalLock
    s3eDeviceLoaderCallStart(S3E_TRUE, NULL);
#endif

    HSAMPLE ret = g_Ext.m_s3eBASS_SampleCreate(length, freq, chans, max, flags);

#ifdef __mips
    s3eDeviceLoaderCallDone(S3E_TRUE, NULL);
#endif

    return ret;
}

BOOL s3eBASS_SampleFree(HSAMPLE handle)
{
    IwTrace(BASS_VERBOSE, ("calling s3eBass[31] func: s3eBASS_SampleFree"));

    if (!_extLoad())
        return false;

#ifdef __mips
    // For MIPs platform we do not have asm code for stack switching 
    // implemented. So we make LoaderCallStart call manually to set GlobalLock
    s3eDeviceLoaderCallStart(S3E_TRUE, NULL);
#endif

    BOOL ret = g_Ext.m_s3eBASS_SampleFree(handle);

#ifdef __mips
    s3eDeviceLoaderCallDone(S3E_TRUE, NULL);
#endif

    return ret;
}

BOOL s3eBASS_SampleSetData(HSAMPLE handle, const void *buffer)
{
    IwTrace(BASS_VERBOSE, ("calling s3eBass[32] func: s3eBASS_SampleSetData"));

    if (!_extLoad())
        return false;

#ifdef __mips
    // For MIPs platform we do not have asm code for stack switching 
    // implemented. So we make LoaderCallStart call manually to set GlobalLock
    s3eDeviceLoaderCallStart(S3E_TRUE, NULL);
#endif

    BOOL ret = g_Ext.m_s3eBASS_SampleSetData(handle, buffer);

#ifdef __mips
    s3eDeviceLoaderCallDone(S3E_TRUE, NULL);
#endif

    return ret;
}

BOOL s3eBASS_SampleGetData(HSAMPLE handle, void *buffer)
{
    IwTrace(BASS_VERBOSE, ("calling s3eBass[33] func: s3eBASS_SampleGetData"));

    if (!_extLoad())
        return false;

#ifdef __mips
    // For MIPs platform we do not have asm code for stack switching 
    // implemented. So we make LoaderCallStart call manually to set GlobalLock
    s3eDeviceLoaderCallStart(S3E_TRUE, NULL);
#endif

    BOOL ret = g_Ext.m_s3eBASS_SampleGetData(handle, buffer);

#ifdef __mips
    s3eDeviceLoaderCallDone(S3E_TRUE, NULL);
#endif

    return ret;
}

BOOL s3eBASS_SampleGetInfo(HSAMPLE handle, BASS_SAMPLE *info)
{
    IwTrace(BASS_VERBOSE, ("calling s3eBass[34] func: s3eBASS_SampleGetInfo"));

    if (!_extLoad())
        return false;

#ifdef __mips
    // For MIPs platform we do not have asm code for stack switching 
    // implemented. So we make LoaderCallStart call manually to set GlobalLock
    s3eDeviceLoaderCallStart(S3E_TRUE, NULL);
#endif

    BOOL ret = g_Ext.m_s3eBASS_SampleGetInfo(handle, info);

#ifdef __mips
    s3eDeviceLoaderCallDone(S3E_TRUE, NULL);
#endif

    return ret;
}

BOOL s3eBASS_SampleSetInfo(HSAMPLE handle, const BASS_SAMPLE *info)
{
    IwTrace(BASS_VERBOSE, ("calling s3eBass[35] func: s3eBASS_SampleSetInfo"));

    if (!_extLoad())
        return false;

#ifdef __mips
    // For MIPs platform we do not have asm code for stack switching 
    // implemented. So we make LoaderCallStart call manually to set GlobalLock
    s3eDeviceLoaderCallStart(S3E_TRUE, NULL);
#endif

    BOOL ret = g_Ext.m_s3eBASS_SampleSetInfo(handle, info);

#ifdef __mips
    s3eDeviceLoaderCallDone(S3E_TRUE, NULL);
#endif

    return ret;
}

HCHANNEL s3eBASS_SampleGetChannel(HSAMPLE handle, BOOL onlynew)
{
    IwTrace(BASS_VERBOSE, ("calling s3eBass[36] func: s3eBASS_SampleGetChannel"));

    if (!_extLoad())
        return NULL;

#ifdef __mips
    // For MIPs platform we do not have asm code for stack switching 
    // implemented. So we make LoaderCallStart call manually to set GlobalLock
    s3eDeviceLoaderCallStart(S3E_TRUE, NULL);
#endif

    HCHANNEL ret = g_Ext.m_s3eBASS_SampleGetChannel(handle, onlynew);

#ifdef __mips
    s3eDeviceLoaderCallDone(S3E_TRUE, NULL);
#endif

    return ret;
}

DWORD s3eBASS_SampleGetChannels(HSAMPLE handle, HCHANNEL *channels)
{
    IwTrace(BASS_VERBOSE, ("calling s3eBass[37] func: s3eBASS_SampleGetChannels"));

    if (!_extLoad())
        return NULL;

#ifdef __mips
    // For MIPs platform we do not have asm code for stack switching 
    // implemented. So we make LoaderCallStart call manually to set GlobalLock
    s3eDeviceLoaderCallStart(S3E_TRUE, NULL);
#endif

    DWORD ret = g_Ext.m_s3eBASS_SampleGetChannels(handle, channels);

#ifdef __mips
    s3eDeviceLoaderCallDone(S3E_TRUE, NULL);
#endif

    return ret;
}

BOOL s3eBASS_SampleStop(HSAMPLE handle)
{
    IwTrace(BASS_VERBOSE, ("calling s3eBass[38] func: s3eBASS_SampleStop"));

    if (!_extLoad())
        return false;

#ifdef __mips
    // For MIPs platform we do not have asm code for stack switching 
    // implemented. So we make LoaderCallStart call manually to set GlobalLock
    s3eDeviceLoaderCallStart(S3E_TRUE, NULL);
#endif

    BOOL ret = g_Ext.m_s3eBASS_SampleStop(handle);

#ifdef __mips
    s3eDeviceLoaderCallDone(S3E_TRUE, NULL);
#endif

    return ret;
}

HSTREAM s3eBASS_StreamCreate(DWORD freq, DWORD chans, DWORD flags, STREAMPROC *proc, void *user)
{
    IwTrace(BASS_VERBOSE, ("calling s3eBass[39] func: s3eBASS_StreamCreate"));

    if (!_extLoad())
        return NULL;

#ifdef __mips
    // For MIPs platform we do not have asm code for stack switching 
    // implemented. So we make LoaderCallStart call manually to set GlobalLock
    s3eDeviceLoaderCallStart(S3E_TRUE, NULL);
#endif

    HSTREAM ret = g_Ext.m_s3eBASS_StreamCreate(freq, chans, flags, proc, user);

#ifdef __mips
    s3eDeviceLoaderCallDone(S3E_TRUE, NULL);
#endif

    return ret;
}

HSTREAM s3eBASS_StreamCreateFile(BOOL mem, const void *file, QWORD offset, QWORD length, DWORD flags)
{
    IwTrace(BASS_VERBOSE, ("calling s3eBass[40] func: s3eBASS_StreamCreateFile"));

    if (!_extLoad())
        return NULL;

#ifdef __mips
    // For MIPs platform we do not have asm code for stack switching 
    // implemented. So we make LoaderCallStart call manually to set GlobalLock
    s3eDeviceLoaderCallStart(S3E_TRUE, NULL);
#endif

    HSTREAM ret = g_Ext.m_s3eBASS_StreamCreateFile(mem, file, offset, length, flags);

#ifdef __mips
    s3eDeviceLoaderCallDone(S3E_TRUE, NULL);
#endif

    return ret;
}

HSTREAM s3eBASS_StreamCreateURL(const char *url, DWORD offset, DWORD flags, DOWNLOADPROC *proc, void *user)
{
    IwTrace(BASS_VERBOSE, ("calling s3eBass[41] func: s3eBASS_StreamCreateURL"));

    if (!_extLoad())
        return NULL;

#ifdef __mips
    // For MIPs platform we do not have asm code for stack switching 
    // implemented. So we make LoaderCallStart call manually to set GlobalLock
    s3eDeviceLoaderCallStart(S3E_TRUE, NULL);
#endif

    HSTREAM ret = g_Ext.m_s3eBASS_StreamCreateURL(url, offset, flags, proc, user);

#ifdef __mips
    s3eDeviceLoaderCallDone(S3E_TRUE, NULL);
#endif

    return ret;
}

HSTREAM s3eBASS_StreamCreateFileUser(DWORD system, DWORD flags, const BASS_FILEPROCS *proc, void *user)
{
    IwTrace(BASS_VERBOSE, ("calling s3eBass[42] func: s3eBASS_StreamCreateFileUser"));

    if (!_extLoad())
        return NULL;

#ifdef __mips
    // For MIPs platform we do not have asm code for stack switching 
    // implemented. So we make LoaderCallStart call manually to set GlobalLock
    s3eDeviceLoaderCallStart(S3E_TRUE, NULL);
#endif

    HSTREAM ret = g_Ext.m_s3eBASS_StreamCreateFileUser(system, flags, proc, user);

#ifdef __mips
    s3eDeviceLoaderCallDone(S3E_TRUE, NULL);
#endif

    return ret;
}

BOOL s3eBASS_StreamFree(HSTREAM handle)
{
    IwTrace(BASS_VERBOSE, ("calling s3eBass[43] func: s3eBASS_StreamFree"));

    if (!_extLoad())
        return false;

#ifdef __mips
    // For MIPs platform we do not have asm code for stack switching 
    // implemented. So we make LoaderCallStart call manually to set GlobalLock
    s3eDeviceLoaderCallStart(S3E_TRUE, NULL);
#endif

    BOOL ret = g_Ext.m_s3eBASS_StreamFree(handle);

#ifdef __mips
    s3eDeviceLoaderCallDone(S3E_TRUE, NULL);
#endif

    return ret;
}

QWORD s3eBASS_StreamGetFilePosition(HSTREAM handle, DWORD mode)
{
    IwTrace(BASS_VERBOSE, ("calling s3eBass[44] func: s3eBASS_StreamGetFilePosition"));

    if (!_extLoad())
        return NULL;

#ifdef __mips
    // For MIPs platform we do not have asm code for stack switching 
    // implemented. So we make LoaderCallStart call manually to set GlobalLock
    s3eDeviceLoaderCallStart(S3E_TRUE, NULL);
#endif

    QWORD ret = g_Ext.m_s3eBASS_StreamGetFilePosition(handle, mode);

#ifdef __mips
    s3eDeviceLoaderCallDone(S3E_TRUE, NULL);
#endif

    return ret;
}

DWORD s3eBASS_StreamPutData(HSTREAM handle, const void *buffer, DWORD length)
{
    IwTrace(BASS_VERBOSE, ("calling s3eBass[45] func: s3eBASS_StreamPutData"));

    if (!_extLoad())
        return NULL;

#ifdef __mips
    // For MIPs platform we do not have asm code for stack switching 
    // implemented. So we make LoaderCallStart call manually to set GlobalLock
    s3eDeviceLoaderCallStart(S3E_TRUE, NULL);
#endif

    DWORD ret = g_Ext.m_s3eBASS_StreamPutData(handle, buffer, length);

#ifdef __mips
    s3eDeviceLoaderCallDone(S3E_TRUE, NULL);
#endif

    return ret;
}

DWORD s3eBASS_StreamPutFileData(HSTREAM handle, const void *buffer, DWORD length)
{
    IwTrace(BASS_VERBOSE, ("calling s3eBass[46] func: s3eBASS_StreamPutFileData"));

    if (!_extLoad())
        return NULL;

#ifdef __mips
    // For MIPs platform we do not have asm code for stack switching 
    // implemented. So we make LoaderCallStart call manually to set GlobalLock
    s3eDeviceLoaderCallStart(S3E_TRUE, NULL);
#endif

    DWORD ret = g_Ext.m_s3eBASS_StreamPutFileData(handle, buffer, length);

#ifdef __mips
    s3eDeviceLoaderCallDone(S3E_TRUE, NULL);
#endif

    return ret;
}

BOOL s3eBASS_RecordGetDeviceInfo(DWORD device, BASS_DEVICEINFO *info)
{
    IwTrace(BASS_VERBOSE, ("calling s3eBass[47] func: s3eBASS_RecordGetDeviceInfo"));

    if (!_extLoad())
        return false;

#ifdef __mips
    // For MIPs platform we do not have asm code for stack switching 
    // implemented. So we make LoaderCallStart call manually to set GlobalLock
    s3eDeviceLoaderCallStart(S3E_TRUE, NULL);
#endif

    BOOL ret = g_Ext.m_s3eBASS_RecordGetDeviceInfo(device, info);

#ifdef __mips
    s3eDeviceLoaderCallDone(S3E_TRUE, NULL);
#endif

    return ret;
}

BOOL s3eBASS_RecordInit(int device)
{
    IwTrace(BASS_VERBOSE, ("calling s3eBass[48] func: s3eBASS_RecordInit"));

    if (!_extLoad())
        return false;

#ifdef __mips
    // For MIPs platform we do not have asm code for stack switching 
    // implemented. So we make LoaderCallStart call manually to set GlobalLock
    s3eDeviceLoaderCallStart(S3E_TRUE, NULL);
#endif

    BOOL ret = g_Ext.m_s3eBASS_RecordInit(device);

#ifdef __mips
    s3eDeviceLoaderCallDone(S3E_TRUE, NULL);
#endif

    return ret;
}

BOOL s3eBASS_RecordSetDevice(DWORD device)
{
    IwTrace(BASS_VERBOSE, ("calling s3eBass[49] func: s3eBASS_RecordSetDevice"));

    if (!_extLoad())
        return false;

#ifdef __mips
    // For MIPs platform we do not have asm code for stack switching 
    // implemented. So we make LoaderCallStart call manually to set GlobalLock
    s3eDeviceLoaderCallStart(S3E_TRUE, NULL);
#endif

    BOOL ret = g_Ext.m_s3eBASS_RecordSetDevice(device);

#ifdef __mips
    s3eDeviceLoaderCallDone(S3E_TRUE, NULL);
#endif

    return ret;
}

DWORD s3eBASS_RecordGetDevice()
{
    IwTrace(BASS_VERBOSE, ("calling s3eBass[50] func: s3eBASS_RecordGetDevice"));

    if (!_extLoad())
        return NULL;

#ifdef __mips
    // For MIPs platform we do not have asm code for stack switching 
    // implemented. So we make LoaderCallStart call manually to set GlobalLock
    s3eDeviceLoaderCallStart(S3E_TRUE, NULL);
#endif

    DWORD ret = g_Ext.m_s3eBASS_RecordGetDevice();

#ifdef __mips
    s3eDeviceLoaderCallDone(S3E_TRUE, NULL);
#endif

    return ret;
}

BOOL s3eBASS_RecordFree()
{
    IwTrace(BASS_VERBOSE, ("calling s3eBass[51] func: s3eBASS_RecordFree"));

    if (!_extLoad())
        return false;

#ifdef __mips
    // For MIPs platform we do not have asm code for stack switching 
    // implemented. So we make LoaderCallStart call manually to set GlobalLock
    s3eDeviceLoaderCallStart(S3E_TRUE, NULL);
#endif

    BOOL ret = g_Ext.m_s3eBASS_RecordFree();

#ifdef __mips
    s3eDeviceLoaderCallDone(S3E_TRUE, NULL);
#endif

    return ret;
}

BOOL s3eBASS_RecordGetInfo(BASS_RECORDINFO *info)
{
    IwTrace(BASS_VERBOSE, ("calling s3eBass[52] func: s3eBASS_RecordGetInfo"));

    if (!_extLoad())
        return false;

#ifdef __mips
    // For MIPs platform we do not have asm code for stack switching 
    // implemented. So we make LoaderCallStart call manually to set GlobalLock
    s3eDeviceLoaderCallStart(S3E_TRUE, NULL);
#endif

    BOOL ret = g_Ext.m_s3eBASS_RecordGetInfo(info);

#ifdef __mips
    s3eDeviceLoaderCallDone(S3E_TRUE, NULL);
#endif

    return ret;
}

const char *s3eBASS_RecordGetInputName(int input)
{
    IwTrace(BASS_VERBOSE, ("calling s3eBass[53] func: *s3eBASS_RecordGetInputName"));

    if (!_extLoad())
        return NULL;

#ifdef __mips
    // For MIPs platform we do not have asm code for stack switching 
    // implemented. So we make LoaderCallStart call manually to set GlobalLock
    s3eDeviceLoaderCallStart(S3E_TRUE, NULL);
#endif

    const char *ret = g_Ext.m_s3eBASS_RecordGetInputName(input);

#ifdef __mips
    s3eDeviceLoaderCallDone(S3E_TRUE, NULL);
#endif

    return ret;
}

BOOL s3eBASS_RecordSetInput(int input, DWORD flags, float volume)
{
    IwTrace(BASS_VERBOSE, ("calling s3eBass[54] func: s3eBASS_RecordSetInput"));

    if (!_extLoad())
        return false;

#ifdef __mips
    // For MIPs platform we do not have asm code for stack switching 
    // implemented. So we make LoaderCallStart call manually to set GlobalLock
    s3eDeviceLoaderCallStart(S3E_TRUE, NULL);
#endif

    BOOL ret = g_Ext.m_s3eBASS_RecordSetInput(input, flags, volume);

#ifdef __mips
    s3eDeviceLoaderCallDone(S3E_TRUE, NULL);
#endif

    return ret;
}

DWORD s3eBASS_RecordGetInput(int input, float *volume)
{
    IwTrace(BASS_VERBOSE, ("calling s3eBass[55] func: s3eBASS_RecordGetInput"));

    if (!_extLoad())
        return false;

#ifdef __mips
    // For MIPs platform we do not have asm code for stack switching 
    // implemented. So we make LoaderCallStart call manually to set GlobalLock
    s3eDeviceLoaderCallStart(S3E_TRUE, NULL);
#endif

    DWORD ret = g_Ext.m_s3eBASS_RecordGetInput(input, volume);

#ifdef __mips
    s3eDeviceLoaderCallDone(S3E_TRUE, NULL);
#endif

    return ret;
}

HRECORD s3eBASS_RecordStart(DWORD freq, DWORD chans, DWORD flags, RECORDPROC *proc, void *user)
{
    IwTrace(BASS_VERBOSE, ("calling s3eBass[56] func: s3eBASS_RecordStart"));

    if (!_extLoad())
        return NULL;

#ifdef __mips
    // For MIPs platform we do not have asm code for stack switching 
    // implemented. So we make LoaderCallStart call manually to set GlobalLock
    s3eDeviceLoaderCallStart(S3E_TRUE, NULL);
#endif

    HRECORD ret = g_Ext.m_s3eBASS_RecordStart(freq, chans, flags, proc, user);

#ifdef __mips
    s3eDeviceLoaderCallDone(S3E_TRUE, NULL);
#endif

    return ret;
}

double s3eBASS_ChannelBytes2Seconds(DWORD handle, QWORD pos)
{
    IwTrace(BASS_VERBOSE, ("calling s3eBass[57] func: s3eBASS_ChannelBytes2Seconds"));

    if (!_extLoad())
        return 0;

#ifdef __mips
    // For MIPs platform we do not have asm code for stack switching 
    // implemented. So we make LoaderCallStart call manually to set GlobalLock
    s3eDeviceLoaderCallStart(S3E_TRUE, NULL);
#endif

    double ret = g_Ext.m_s3eBASS_ChannelBytes2Seconds(handle, pos);

#ifdef __mips
    s3eDeviceLoaderCallDone(S3E_TRUE, NULL);
#endif

    return ret;
}

QWORD s3eBASS_ChannelSeconds2Bytes(DWORD handle, double pos)
{
    IwTrace(BASS_VERBOSE, ("calling s3eBass[58] func: s3eBASS_ChannelSeconds2Bytes"));

    if (!_extLoad())
        return 0;

#ifdef __mips
    // For MIPs platform we do not have asm code for stack switching 
    // implemented. So we make LoaderCallStart call manually to set GlobalLock
    s3eDeviceLoaderCallStart(S3E_TRUE, NULL);
#endif

    QWORD ret = g_Ext.m_s3eBASS_ChannelSeconds2Bytes(handle, pos);

#ifdef __mips
    s3eDeviceLoaderCallDone(S3E_TRUE, NULL);
#endif

    return ret;
}

DWORD s3eBASS_ChannelGetDevice(DWORD handle)
{
    IwTrace(BASS_VERBOSE, ("calling s3eBass[59] func: s3eBASS_ChannelGetDevice"));

    if (!_extLoad())
        return NULL;

#ifdef __mips
    // For MIPs platform we do not have asm code for stack switching 
    // implemented. So we make LoaderCallStart call manually to set GlobalLock
    s3eDeviceLoaderCallStart(S3E_TRUE, NULL);
#endif

    DWORD ret = g_Ext.m_s3eBASS_ChannelGetDevice(handle);

#ifdef __mips
    s3eDeviceLoaderCallDone(S3E_TRUE, NULL);
#endif

    return ret;
}

BOOL s3eBASS_ChannelSetDevice(DWORD handle, DWORD device)
{
    IwTrace(BASS_VERBOSE, ("calling s3eBass[60] func: s3eBASS_ChannelSetDevice"));

    if (!_extLoad())
        return false;

#ifdef __mips
    // For MIPs platform we do not have asm code for stack switching 
    // implemented. So we make LoaderCallStart call manually to set GlobalLock
    s3eDeviceLoaderCallStart(S3E_TRUE, NULL);
#endif

    BOOL ret = g_Ext.m_s3eBASS_ChannelSetDevice(handle, device);

#ifdef __mips
    s3eDeviceLoaderCallDone(S3E_TRUE, NULL);
#endif

    return ret;
}

DWORD s3eBASS_ChannelIsActive(DWORD handle)
{
    IwTrace(BASS_VERBOSE, ("calling s3eBass[61] func: s3eBASS_ChannelIsActive"));

    if (!_extLoad())
        return NULL;

#ifdef __mips
    // For MIPs platform we do not have asm code for stack switching 
    // implemented. So we make LoaderCallStart call manually to set GlobalLock
    s3eDeviceLoaderCallStart(S3E_TRUE, NULL);
#endif

    DWORD ret = g_Ext.m_s3eBASS_ChannelIsActive(handle);

#ifdef __mips
    s3eDeviceLoaderCallDone(S3E_TRUE, NULL);
#endif

    return ret;
}

BOOL s3eBASS_ChannelGetInfo(DWORD handle, BASS_CHANNELINFO *info)
{
    IwTrace(BASS_VERBOSE, ("calling s3eBass[62] func: s3eBASS_ChannelGetInfo"));

    if (!_extLoad())
        return false;

#ifdef __mips
    // For MIPs platform we do not have asm code for stack switching 
    // implemented. So we make LoaderCallStart call manually to set GlobalLock
    s3eDeviceLoaderCallStart(S3E_TRUE, NULL);
#endif

    BOOL ret = g_Ext.m_s3eBASS_ChannelGetInfo(handle, info);

#ifdef __mips
    s3eDeviceLoaderCallDone(S3E_TRUE, NULL);
#endif

    return ret;
}

const char *s3eBASS_ChannelGetTags(DWORD handle, DWORD tags)
{
    IwTrace(BASS_VERBOSE, ("calling s3eBass[63] func: *s3eBASS_ChannelGetTags"));

    if (!_extLoad())
        return NULL;

#ifdef __mips
    // For MIPs platform we do not have asm code for stack switching 
    // implemented. So we make LoaderCallStart call manually to set GlobalLock
    s3eDeviceLoaderCallStart(S3E_TRUE, NULL);
#endif

    const char *ret = g_Ext.m_s3eBASS_ChannelGetTags(handle, tags);

#ifdef __mips
    s3eDeviceLoaderCallDone(S3E_TRUE, NULL);
#endif

    return ret;
}

DWORD s3eBASS_ChannelFlags(DWORD handle, DWORD flags, DWORD mask)
{
    IwTrace(BASS_VERBOSE, ("calling s3eBass[64] func: s3eBASS_ChannelFlags"));

    if (!_extLoad())
        return NULL;

#ifdef __mips
    // For MIPs platform we do not have asm code for stack switching 
    // implemented. So we make LoaderCallStart call manually to set GlobalLock
    s3eDeviceLoaderCallStart(S3E_TRUE, NULL);
#endif

    DWORD ret = g_Ext.m_s3eBASS_ChannelFlags(handle, flags, mask);

#ifdef __mips
    s3eDeviceLoaderCallDone(S3E_TRUE, NULL);
#endif

    return ret;
}

BOOL s3eBASS_ChannelUpdate(DWORD handle, DWORD length)
{
    IwTrace(BASS_VERBOSE, ("calling s3eBass[65] func: s3eBASS_ChannelUpdate"));

    if (!_extLoad())
        return false;

#ifdef __mips
    // For MIPs platform we do not have asm code for stack switching 
    // implemented. So we make LoaderCallStart call manually to set GlobalLock
    s3eDeviceLoaderCallStart(S3E_TRUE, NULL);
#endif

    BOOL ret = g_Ext.m_s3eBASS_ChannelUpdate(handle, length);

#ifdef __mips
    s3eDeviceLoaderCallDone(S3E_TRUE, NULL);
#endif

    return ret;
}

BOOL s3eBASS_ChannelLock(DWORD handle, BOOL lock)
{
    IwTrace(BASS_VERBOSE, ("calling s3eBass[66] func: s3eBASS_ChannelLock"));

    if (!_extLoad())
        return false;

#ifdef __mips
    // For MIPs platform we do not have asm code for stack switching 
    // implemented. So we make LoaderCallStart call manually to set GlobalLock
    s3eDeviceLoaderCallStart(S3E_TRUE, NULL);
#endif

    BOOL ret = g_Ext.m_s3eBASS_ChannelLock(handle, lock);

#ifdef __mips
    s3eDeviceLoaderCallDone(S3E_TRUE, NULL);
#endif

    return ret;
}

BOOL s3eBASS_ChannelPlay(DWORD handle, BOOL restart)
{
    IwTrace(BASS_VERBOSE, ("calling s3eBass[67] func: s3eBASS_ChannelPlay"));

    if (!_extLoad())
        return false;

#ifdef __mips
    // For MIPs platform we do not have asm code for stack switching 
    // implemented. So we make LoaderCallStart call manually to set GlobalLock
    s3eDeviceLoaderCallStart(S3E_TRUE, NULL);
#endif

    BOOL ret = g_Ext.m_s3eBASS_ChannelPlay(handle, restart);

#ifdef __mips
    s3eDeviceLoaderCallDone(S3E_TRUE, NULL);
#endif

    return ret;
}

BOOL s3eBASS_ChannelStop(DWORD handle)
{
    IwTrace(BASS_VERBOSE, ("calling s3eBass[68] func: s3eBASS_ChannelStop"));

    if (!_extLoad())
        return false;

#ifdef __mips
    // For MIPs platform we do not have asm code for stack switching 
    // implemented. So we make LoaderCallStart call manually to set GlobalLock
    s3eDeviceLoaderCallStart(S3E_TRUE, NULL);
#endif

    BOOL ret = g_Ext.m_s3eBASS_ChannelStop(handle);

#ifdef __mips
    s3eDeviceLoaderCallDone(S3E_TRUE, NULL);
#endif

    return ret;
}

BOOL s3eBASS_ChannelPause(DWORD handle)
{
    IwTrace(BASS_VERBOSE, ("calling s3eBass[69] func: s3eBASS_ChannelPause"));

    if (!_extLoad())
        return false;

#ifdef __mips
    // For MIPs platform we do not have asm code for stack switching 
    // implemented. So we make LoaderCallStart call manually to set GlobalLock
    s3eDeviceLoaderCallStart(S3E_TRUE, NULL);
#endif

    BOOL ret = g_Ext.m_s3eBASS_ChannelPause(handle);

#ifdef __mips
    s3eDeviceLoaderCallDone(S3E_TRUE, NULL);
#endif

    return ret;
}

BOOL s3eBASS_ChannelSetAttribute(DWORD handle, DWORD attrib, float value)
{
    IwTrace(BASS_VERBOSE, ("calling s3eBass[70] func: s3eBASS_ChannelSetAttribute"));

    if (!_extLoad())
        return false;

#ifdef __mips
    // For MIPs platform we do not have asm code for stack switching 
    // implemented. So we make LoaderCallStart call manually to set GlobalLock
    s3eDeviceLoaderCallStart(S3E_TRUE, NULL);
#endif

    BOOL ret = g_Ext.m_s3eBASS_ChannelSetAttribute(handle, attrib, value);

#ifdef __mips
    s3eDeviceLoaderCallDone(S3E_TRUE, NULL);
#endif

    return ret;
}

BOOL s3eBASS_ChannelGetAttribute(DWORD handle, DWORD attrib, float *value)
{
    IwTrace(BASS_VERBOSE, ("calling s3eBass[71] func: s3eBASS_ChannelGetAttribute"));

    if (!_extLoad())
        return false;

#ifdef __mips
    // For MIPs platform we do not have asm code for stack switching 
    // implemented. So we make LoaderCallStart call manually to set GlobalLock
    s3eDeviceLoaderCallStart(S3E_TRUE, NULL);
#endif

    BOOL ret = g_Ext.m_s3eBASS_ChannelGetAttribute(handle, attrib, value);

#ifdef __mips
    s3eDeviceLoaderCallDone(S3E_TRUE, NULL);
#endif

    return ret;
}

BOOL s3eBASS_ChannelSlideAttribute(DWORD handle, DWORD attrib, float value, DWORD time)
{
    IwTrace(BASS_VERBOSE, ("calling s3eBass[72] func: s3eBASS_ChannelSlideAttribute"));

    if (!_extLoad())
        return false;

#ifdef __mips
    // For MIPs platform we do not have asm code for stack switching 
    // implemented. So we make LoaderCallStart call manually to set GlobalLock
    s3eDeviceLoaderCallStart(S3E_TRUE, NULL);
#endif

    BOOL ret = g_Ext.m_s3eBASS_ChannelSlideAttribute(handle, attrib, value, time);

#ifdef __mips
    s3eDeviceLoaderCallDone(S3E_TRUE, NULL);
#endif

    return ret;
}

BOOL s3eBASS_ChannelIsSliding(DWORD handle, DWORD attrib)
{
    IwTrace(BASS_VERBOSE, ("calling s3eBass[73] func: s3eBASS_ChannelIsSliding"));

    if (!_extLoad())
        return false;

#ifdef __mips
    // For MIPs platform we do not have asm code for stack switching 
    // implemented. So we make LoaderCallStart call manually to set GlobalLock
    s3eDeviceLoaderCallStart(S3E_TRUE, NULL);
#endif

    BOOL ret = g_Ext.m_s3eBASS_ChannelIsSliding(handle, attrib);

#ifdef __mips
    s3eDeviceLoaderCallDone(S3E_TRUE, NULL);
#endif

    return ret;
}

BOOL s3eBASS_ChannelSet3DAttributes(DWORD handle, int mode, float min, float max, int iangle, int oangle, float outvol)
{
    IwTrace(BASS_VERBOSE, ("calling s3eBass[74] func: s3eBASS_ChannelSet3DAttributes"));

    if (!_extLoad())
        return false;

#ifdef __mips
    // For MIPs platform we do not have asm code for stack switching 
    // implemented. So we make LoaderCallStart call manually to set GlobalLock
    s3eDeviceLoaderCallStart(S3E_TRUE, NULL);
#endif

    BOOL ret = g_Ext.m_s3eBASS_ChannelSet3DAttributes(handle, mode, min, max, iangle, oangle, outvol);

#ifdef __mips
    s3eDeviceLoaderCallDone(S3E_TRUE, NULL);
#endif

    return ret;
}

BOOL s3eBASS_ChannelGet3DAttributes(DWORD handle, DWORD *mode, float *min, float *max, DWORD *iangle, DWORD *oangle, float *outvol)
{
    IwTrace(BASS_VERBOSE, ("calling s3eBass[75] func: s3eBASS_ChannelGet3DAttributes"));

    if (!_extLoad())
        return false;

#ifdef __mips
    // For MIPs platform we do not have asm code for stack switching 
    // implemented. So we make LoaderCallStart call manually to set GlobalLock
    s3eDeviceLoaderCallStart(S3E_TRUE, NULL);
#endif

    BOOL ret = g_Ext.m_s3eBASS_ChannelGet3DAttributes(handle, mode, min, max, iangle, oangle, outvol);

#ifdef __mips
    s3eDeviceLoaderCallDone(S3E_TRUE, NULL);
#endif

    return ret;
}

BOOL s3eBASS_ChannelSet3DPosition(DWORD handle, const BASS_3DVECTOR *pos, const BASS_3DVECTOR *orient, const BASS_3DVECTOR *vel)
{
    IwTrace(BASS_VERBOSE, ("calling s3eBass[76] func: s3eBASS_ChannelSet3DPosition"));

    if (!_extLoad())
        return false;

#ifdef __mips
    // For MIPs platform we do not have asm code for stack switching 
    // implemented. So we make LoaderCallStart call manually to set GlobalLock
    s3eDeviceLoaderCallStart(S3E_TRUE, NULL);
#endif

    BOOL ret = g_Ext.m_s3eBASS_ChannelSet3DPosition(handle, pos, orient, vel);

#ifdef __mips
    s3eDeviceLoaderCallDone(S3E_TRUE, NULL);
#endif

    return ret;
}

BOOL s3eBASS_ChannelGet3DPosition(DWORD handle, BASS_3DVECTOR *pos, BASS_3DVECTOR *orient, BASS_3DVECTOR *vel)
{
    IwTrace(BASS_VERBOSE, ("calling s3eBass[77] func: s3eBASS_ChannelGet3DPosition"));

    if (!_extLoad())
        return false;

#ifdef __mips
    // For MIPs platform we do not have asm code for stack switching 
    // implemented. So we make LoaderCallStart call manually to set GlobalLock
    s3eDeviceLoaderCallStart(S3E_TRUE, NULL);
#endif

    BOOL ret = g_Ext.m_s3eBASS_ChannelGet3DPosition(handle, pos, orient, vel);

#ifdef __mips
    s3eDeviceLoaderCallDone(S3E_TRUE, NULL);
#endif

    return ret;
}

QWORD s3eBASS_ChannelGetLength(DWORD handle, DWORD mode)
{
    IwTrace(BASS_VERBOSE, ("calling s3eBass[78] func: s3eBASS_ChannelGetLength"));

    if (!_extLoad())
        return NULL;

#ifdef __mips
    // For MIPs platform we do not have asm code for stack switching 
    // implemented. So we make LoaderCallStart call manually to set GlobalLock
    s3eDeviceLoaderCallStart(S3E_TRUE, NULL);
#endif

    QWORD ret = g_Ext.m_s3eBASS_ChannelGetLength(handle, mode);

#ifdef __mips
    s3eDeviceLoaderCallDone(S3E_TRUE, NULL);
#endif

    return ret;
}

BOOL s3eBASS_ChannelSetPosition(DWORD handle, QWORD pos, DWORD mode)
{
    IwTrace(BASS_VERBOSE, ("calling s3eBass[79] func: s3eBASS_ChannelSetPosition"));

    if (!_extLoad())
        return false;

#ifdef __mips
    // For MIPs platform we do not have asm code for stack switching 
    // implemented. So we make LoaderCallStart call manually to set GlobalLock
    s3eDeviceLoaderCallStart(S3E_TRUE, NULL);
#endif

    BOOL ret = g_Ext.m_s3eBASS_ChannelSetPosition(handle, pos, mode);

#ifdef __mips
    s3eDeviceLoaderCallDone(S3E_TRUE, NULL);
#endif

    return ret;
}

QWORD s3eBASS_ChannelGetPosition(DWORD handle, DWORD mode)
{
    IwTrace(BASS_VERBOSE, ("calling s3eBass[80] func: s3eBASS_ChannelGetPosition"));

    if (!_extLoad())
        return NULL;

#ifdef __mips
    // For MIPs platform we do not have asm code for stack switching 
    // implemented. So we make LoaderCallStart call manually to set GlobalLock
    s3eDeviceLoaderCallStart(S3E_TRUE, NULL);
#endif

    QWORD ret = g_Ext.m_s3eBASS_ChannelGetPosition(handle, mode);

#ifdef __mips
    s3eDeviceLoaderCallDone(S3E_TRUE, NULL);
#endif

    return ret;
}

DWORD s3eBASS_ChannelGetLevel(DWORD handle)
{
    IwTrace(BASS_VERBOSE, ("calling s3eBass[81] func: s3eBASS_ChannelGetLevel"));

    if (!_extLoad())
        return NULL;

#ifdef __mips
    // For MIPs platform we do not have asm code for stack switching 
    // implemented. So we make LoaderCallStart call manually to set GlobalLock
    s3eDeviceLoaderCallStart(S3E_TRUE, NULL);
#endif

    DWORD ret = g_Ext.m_s3eBASS_ChannelGetLevel(handle);

#ifdef __mips
    s3eDeviceLoaderCallDone(S3E_TRUE, NULL);
#endif

    return ret;
}

DWORD s3eBASS_ChannelGetData(DWORD handle, void *buffer, DWORD length)
{
    IwTrace(BASS_VERBOSE, ("calling s3eBass[82] func: s3eBASS_ChannelGetData"));

    if (!_extLoad())
        return NULL;

#ifdef __mips
    // For MIPs platform we do not have asm code for stack switching 
    // implemented. So we make LoaderCallStart call manually to set GlobalLock
    s3eDeviceLoaderCallStart(S3E_TRUE, NULL);
#endif

    DWORD ret = g_Ext.m_s3eBASS_ChannelGetData(handle, buffer, length);

#ifdef __mips
    s3eDeviceLoaderCallDone(S3E_TRUE, NULL);
#endif

    return ret;
}

HSYNC s3eBASS_ChannelSetSync(DWORD handle, DWORD type, QWORD param, SYNCPROC *proc, void *user)
{
    IwTrace(BASS_VERBOSE, ("calling s3eBass[83] func: s3eBASS_ChannelSetSync"));

    if (!_extLoad())
        return NULL;

#ifdef __mips
    // For MIPs platform we do not have asm code for stack switching 
    // implemented. So we make LoaderCallStart call manually to set GlobalLock
    s3eDeviceLoaderCallStart(S3E_TRUE, NULL);
#endif

    HSYNC ret = g_Ext.m_s3eBASS_ChannelSetSync(handle, type, param, proc, user);

#ifdef __mips
    s3eDeviceLoaderCallDone(S3E_TRUE, NULL);
#endif

    return ret;
}

BOOL s3eBASS_ChannelRemoveSync(DWORD handle, HSYNC sync)
{
    IwTrace(BASS_VERBOSE, ("calling s3eBass[84] func: s3eBASS_ChannelRemoveSync"));

    if (!_extLoad())
        return false;

#ifdef __mips
    // For MIPs platform we do not have asm code for stack switching 
    // implemented. So we make LoaderCallStart call manually to set GlobalLock
    s3eDeviceLoaderCallStart(S3E_TRUE, NULL);
#endif

    BOOL ret = g_Ext.m_s3eBASS_ChannelRemoveSync(handle, sync);

#ifdef __mips
    s3eDeviceLoaderCallDone(S3E_TRUE, NULL);
#endif

    return ret;
}

HDSP s3eBASS_ChannelSetDSP(DWORD handle, DSPPROC *proc, void *user, int priority)
{
    IwTrace(BASS_VERBOSE, ("calling s3eBass[85] func: s3eBASS_ChannelSetDSP"));

    if (!_extLoad())
        return NULL;

#ifdef __mips
    // For MIPs platform we do not have asm code for stack switching 
    // implemented. So we make LoaderCallStart call manually to set GlobalLock
    s3eDeviceLoaderCallStart(S3E_TRUE, NULL);
#endif

    HDSP ret = g_Ext.m_s3eBASS_ChannelSetDSP(handle, proc, user, priority);

#ifdef __mips
    s3eDeviceLoaderCallDone(S3E_TRUE, NULL);
#endif

    return ret;
}

BOOL s3eBASS_ChannelRemoveDSP(DWORD handle, HDSP dsp)
{
    IwTrace(BASS_VERBOSE, ("calling s3eBass[86] func: s3eBASS_ChannelRemoveDSP"));

    if (!_extLoad())
        return false;

#ifdef __mips
    // For MIPs platform we do not have asm code for stack switching 
    // implemented. So we make LoaderCallStart call manually to set GlobalLock
    s3eDeviceLoaderCallStart(S3E_TRUE, NULL);
#endif

    BOOL ret = g_Ext.m_s3eBASS_ChannelRemoveDSP(handle, dsp);

#ifdef __mips
    s3eDeviceLoaderCallDone(S3E_TRUE, NULL);
#endif

    return ret;
}

BOOL s3eBASS_ChannelSetLink(DWORD handle, DWORD chan)
{
    IwTrace(BASS_VERBOSE, ("calling s3eBass[87] func: s3eBASS_ChannelSetLink"));

    if (!_extLoad())
        return false;

#ifdef __mips
    // For MIPs platform we do not have asm code for stack switching 
    // implemented. So we make LoaderCallStart call manually to set GlobalLock
    s3eDeviceLoaderCallStart(S3E_TRUE, NULL);
#endif

    BOOL ret = g_Ext.m_s3eBASS_ChannelSetLink(handle, chan);

#ifdef __mips
    s3eDeviceLoaderCallDone(S3E_TRUE, NULL);
#endif

    return ret;
}

BOOL s3eBASS_ChannelRemoveLink(DWORD handle, DWORD chan)
{
    IwTrace(BASS_VERBOSE, ("calling s3eBass[88] func: s3eBASS_ChannelRemoveLink"));

    if (!_extLoad())
        return false;

#ifdef __mips
    // For MIPs platform we do not have asm code for stack switching 
    // implemented. So we make LoaderCallStart call manually to set GlobalLock
    s3eDeviceLoaderCallStart(S3E_TRUE, NULL);
#endif

    BOOL ret = g_Ext.m_s3eBASS_ChannelRemoveLink(handle, chan);

#ifdef __mips
    s3eDeviceLoaderCallDone(S3E_TRUE, NULL);
#endif

    return ret;
}

HFX s3eBASS_ChannelSetFX(DWORD handle, DWORD type, int priority)
{
    IwTrace(BASS_VERBOSE, ("calling s3eBass[89] func: s3eBASS_ChannelSetFX"));

    if (!_extLoad())
        return NULL;

#ifdef __mips
    // For MIPs platform we do not have asm code for stack switching 
    // implemented. So we make LoaderCallStart call manually to set GlobalLock
    s3eDeviceLoaderCallStart(S3E_TRUE, NULL);
#endif

    HFX ret = g_Ext.m_s3eBASS_ChannelSetFX(handle, type, priority);

#ifdef __mips
    s3eDeviceLoaderCallDone(S3E_TRUE, NULL);
#endif

    return ret;
}

BOOL s3eBASS_ChannelRemoveFX(DWORD handle, HFX fx)
{
    IwTrace(BASS_VERBOSE, ("calling s3eBass[90] func: s3eBASS_ChannelRemoveFX"));

    if (!_extLoad())
        return false;

#ifdef __mips
    // For MIPs platform we do not have asm code for stack switching 
    // implemented. So we make LoaderCallStart call manually to set GlobalLock
    s3eDeviceLoaderCallStart(S3E_TRUE, NULL);
#endif

    BOOL ret = g_Ext.m_s3eBASS_ChannelRemoveFX(handle, fx);

#ifdef __mips
    s3eDeviceLoaderCallDone(S3E_TRUE, NULL);
#endif

    return ret;
}

BOOL s3eBASS_FXSetParameters(HFX handle, const void *params)
{
    IwTrace(BASS_VERBOSE, ("calling s3eBass[91] func: s3eBASS_FXSetParameters"));

    if (!_extLoad())
        return false;

#ifdef __mips
    // For MIPs platform we do not have asm code for stack switching 
    // implemented. So we make LoaderCallStart call manually to set GlobalLock
    s3eDeviceLoaderCallStart(S3E_TRUE, NULL);
#endif

    BOOL ret = g_Ext.m_s3eBASS_FXSetParameters(handle, params);

#ifdef __mips
    s3eDeviceLoaderCallDone(S3E_TRUE, NULL);
#endif

    return ret;
}

BOOL s3eBASS_FXGetParameters(HFX handle, void *params)
{
    IwTrace(BASS_VERBOSE, ("calling s3eBass[92] func: s3eBASS_FXGetParameters"));

    if (!_extLoad())
        return false;

#ifdef __mips
    // For MIPs platform we do not have asm code for stack switching 
    // implemented. So we make LoaderCallStart call manually to set GlobalLock
    s3eDeviceLoaderCallStart(S3E_TRUE, NULL);
#endif

    BOOL ret = g_Ext.m_s3eBASS_FXGetParameters(handle, params);

#ifdef __mips
    s3eDeviceLoaderCallDone(S3E_TRUE, NULL);
#endif

    return ret;
}

BOOL s3eBASS_FXReset(HFX handle)
{
    IwTrace(BASS_VERBOSE, ("calling s3eBass[93] func: s3eBASS_FXReset"));

    if (!_extLoad())
        return false;

#ifdef __mips
    // For MIPs platform we do not have asm code for stack switching 
    // implemented. So we make LoaderCallStart call manually to set GlobalLock
    s3eDeviceLoaderCallStart(S3E_TRUE, NULL);
#endif

    BOOL ret = g_Ext.m_s3eBASS_FXReset(handle);

#ifdef __mips
    s3eDeviceLoaderCallDone(S3E_TRUE, NULL);
#endif

    return ret;
}
